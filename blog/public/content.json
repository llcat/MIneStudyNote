[{"title":"Spring学习笔记","date":"2017-04-27T14:34:46.000Z","path":"spring-framework/Spring学习笔记/2017-04/","text":"参阅git-bookauthor-csdnspring-frame references zh","tags":[{"name":"spring","slug":"spring","permalink":"https://llcat.github.io/tags/spring/"}]},{"title":"SQL基础","date":"2017-04-20T11:53:45.000Z","path":"database/SQL基础/2017-04/","text":"梳理一遍SQL的基本语法本文是对SQL基础语法( 主要是MySQL）的一个回顾和总结，从最基础的单表查询开始，对查询结果进行过滤，排序，分组，聚合等操作，以及后续表连接查询，插入，更新删除数据，使用视图，存储过程，管理事务处理等知识点的回顾。 参考书目《SQL必知必会》，下面实验中使用表及数据均是本书作者提供的，我写这篇文章的目的是对本书中所有的例子进行动手实现，加强自己对SQL语法的理解。如果你感兴趣的话和我一起吧！建表及数据资源 目录： 检索数据 排序检索数据 过滤数据 待续 检索数据 虽然SQL并不区分大小写，但由于不同软件的实现不同，导致有差异，如mysql忽略关键字和列名大小写，但是对表名的大小写是敏感的，这里我们规定下SQL的写法，对于关键字统一采用大写，表名使用大写开头，列名默认情况下使用小写，方便理解 单列，多列，所有列 ( *通配 ) 123456-- 检索单列SELECT prod_name FROM Products;-- 检索多列SELECT prod_id, prod_name, prod_price FROM Products;-- 检索表中的所有列SELECT * FROM Products; 检索不同的值(去重)&amp;限制结果集大小 DISTINCT关键字：DISTINCT关键字作用于后面跟随的所有列，不仅仅是只作用于紧跟于其后的一列 LIMIT 和 OFFSET 关键字：LIMIT关键字是用来限制返回结果集的大小的，而OFFSET关键字是定义开始限制的位置，也就是在结果集中的偏移量。一般我们这样使用: LIMIT 5 OFFSET 2；在MYSQL中可以只使用LIMIT关键字来定义偏移值和返回的结果集大小：LIMIT NUM1, NUM2 {NUM1:偏移量，NUM2：返回结果集大小} 12345678-- 检索不同的值-- 不使用DISTINCT关键字时，由于一个厂家生产多个产品，所以会有多个相同的厂商idSELECT DISTINCT vend_id FROM Products;-- 检索去除厂商id和价格都相同的行SELECT DISTINCT vend_id, prod_prices FROM Products;-- 返回查询结果集的从第3条到7条数据，MySQL中行数从0开始算。SELECT prod_name FROM Products LIMIT 2, 5;SELECT prod_name FROM Products LIMIT 5 OFFSET 2; 排序检索数据 排序检索的数据 ORDER BY 关键字：ORDER BY 关键字对查询的结果集进行排序，注意，ORDER BY 子句一定是一条SELECT语句的最后一个子句，ORDER BY不仅可以根据单列，多列排序，还可以通过关键字DESC(DESCENDING)，ASC(ASCENDING，升序是默认的排序方式，可以不指定) 12345678-- 根据单列排序SELECT prod_name FROM Products ORDER BY prod_name;-- 根据多列排序(会现根据第一列排好序，在保证第一列有序(有相同值，如下面例子中的prod_price价格相等时）的情况下对指定的第2列进行排序，后面指定的字段依照此规则)SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price, prod_name;-- 检索结果按照prod_price, prod_name降序排列SELECT prod_id, prod_price, prod_name FROM Products ORDER BY prod_price DESC , prod_name DESC; tips：并非一定只能指定检索的字段，还可以制定排序的字段是表中存在的其他字段。DESC关键字仅对修饰的一个字段起作用，要多个降序排列，请指定多个DESC字段。 过滤数据 WHERE关键字：数据库表中通常情况下保存了大量的数据，一般业务情况下我们不可能需要全部的数据，我们需要指定一些条件对查询的结果集做限定，这些条件我们称为搜索条件，也叫过滤条件。 where支持的比较操作符 操作符 说明 操作符 说明 = 等于 &gt; 大于 &lt;&gt; 不等于 &gt;= 大于等于 != 不等于 !&gt; 不大于 &lt; 小于 BETWEEN 在两个值之间 &lt;= 小于等于 IS NULL 为 NULL值 !&lt; 不小于 12345678-- 等于操作SELECT prod_name, prod_price FROM Products WHERE prod_price= 3.49;-- 不等于操作SELECT vend_id, prod_name FROM Products WHERE vend_id != 'DLL01';-- BETWEEN操作SELECT prod_name , prod_price FROM Products WHRER prod_price BETWEEN 5 AND 10;-- IS NULL判断SELECT prod_name FROM Products WHERE prod_prices IS NULL; 高级数据过滤 AND, OR 组合查询条件 可以使用 AND 和 OR 组合查询条件，但是要注意，在进行复杂组合使用时我们最好能对条件进行分组，不要依赖默认求值顺序。AND的优先级高于OR。 12","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://llcat.github.io/tags/MySQL/"}]},{"title":"java 笔面题总结","date":"2017-04-19T16:03:34.000Z","path":"java/java-笔面题总结/2017-04/","text":"笔面题总结目录： Java相关 Web开发相关 数据库相关 框架相关 设计模式相关 Java相关 based knowledge switch能用于那些基本数据类型？switch能用于的基本类型有 byte, char, short, intswitch能用于的引用类型：Byte，Character，Short，Integer（上面4种基本类型的包装类），String（jdk版本&gt;=1.7)，enum switch为什么不能作用于long(长整型）?switch 语句被设计成跳转表，表面上看支持很多类型，但实际上只有一种，那就是 int 型，小于 int 的类型都会自动提升成 int。编译时，switch (abc) 语句被当成 goto addrs[abc]，而这一句被实现成机器指令时就成为 表首地址 + 偏移量，所以一个 abc 其实代表了一个偏移地址。至于为什么不能使用long，可能是在Java语言中设计switch语句考虑平台的兼容问题，很多机器还是32位机器。 String String 是基本数据类型吗？不是，java中的基本数据类型有8种，分别是byte, char, short, int, long, float, double, boolean IO Exception 谈谈Java中异常的原理和应用异常是指Java在运行时出现的非正常情况，Java也使用面向对象的思想来处理这些情况，将一些异常信息封装在类中来表示，Java中的异常分为两类Exception和Error，这两个都是Throwable的子类，Error是指程序中出现一些奔溃，程序不能继续运行的错误。 Web开发相关 based knowledge 请简述Session 和 Cookie 的区别 数据库相关 查询记录使其没有重复的值 查分低于60分为不及格，大于60分为及格，大于80分为优秀 新建表A，复制表B中内容至表A，保证表结构一致 查询部门工资最高的前3人 查询部门工资高于平均工资的人 框架相关 设计模式相关 单例模式 请写一个你认为好的单例模式考虑到单例模式需要防范下面几点：(1) 多线程安全(2) 反序列化(3) 反射攻击先说说可以保证多线程安全的方法使用静态变量初始化单例 1234567891011class SingletonByStatic&#123; private static SingletonByStatic instance = new SingletonByStatic(); private SingletonByStatic()&#123; &#125; public static SingletonByStatic getInstance()&#123; return instance; &#125;&#125; 静态内部类(可以实现懒加载，在使用时才会初始化，而不是当类被加载时instance就被初始化呢。 12345678910111213class SingletonByStaticNestedClass&#123; private SingletonByStaticNestedClass()&#123; &#125; private static class SingletonHolder&#123; private static SingletonByStaticNestedClass instance = new SingletonByStaticNestedClass(); &#125; public static SingletonByStaticNestedClass getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 使用枚举（推荐，代码简单，并且保证了反序列化不唯一或者反射攻击) 1234567891011enum SingletonByEnum&#123; INSTANCE&#123; @Override public void infos()&#123; System.out.print(\"i am a singleton\"); &#125; &#125;; protected abstract void infos();&#125;","tags":[{"name":"database","slug":"database","permalink":"https://llcat.github.io/tags/database/"},{"name":"web","slug":"web","permalink":"https://llcat.github.io/tags/web/"},{"name":"java","slug":"java","permalink":"https://llcat.github.io/tags/java/"}]},{"title":"了解Map容器","date":"2017-04-19T07:31:36.000Z","path":"java/了解Map容器/2017-04/","text":"一起看看Map容器吧之前学习Java容器类时做的笔记, 做为从wiznote中转移的第一篇文章, 主要是探讨了一下map容器, 我们如何去写一个hashmap? Java自带的hashmap底层实现是怎么样的呢? 带着这些问题,看看我们下面的内容吧! 写一个自己的简单map 关于散列和散列码 更进一步,如何写个HashMap容器 写一个自己的简单map 我们来深入看看Map容器，他是如何工作的，有哪些类型的Map容器，我们如何选择自己需要的Map容器。通常map容器也被叫做映射表，或者是关联数组，因为他是用来存储一组相关联的数据，即一组键值对，在标准的java容器类中包含下面几种类型的MAP实现: HashMap TreeMap LinkedHashMap WeakHashMap ConcurrentHashMap 它们根据一些实际需求，在查找，键值对的保存顺序，是否支持并发而有一些不同的实现。我们今天不对他们的全部进行探讨,选取其中用的较多的hashmap来看一下吧。 step 1首先我们实现一个最简单的Map容器，他的底层是个数组，不支持扩展大小，查询效率也非常低，并且他不能对键值的唯一性保证。如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MappingTable&lt;K,V&gt;&#123; private Object[][] pairs; int index; public MappingTable(int length)&#123; pairs = new Object[length][2]; &#125; public void put(K key,V value)&#123; for(int i=0;i&lt;index;i++)&#123; if(key.equals(pairs[i][0]))&#123; pairs[i]=new Object[]&#123;key,value&#125;; return ; &#125; &#125; if(index&gt;=pairs.length)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; pairs[index++] = new Object[]&#123;key,value&#125;; &#125; @SuppressWarnings(\"unchecked\") public V get(K key)&#123; for(int i=0;i&lt;pairs.length;i++)&#123; if(key.equals(pairs[i][0]))&#123; return (V)pairs[i][1]; &#125; &#125; return null; &#125; public String toString()&#123; StringBuilder builder = new StringBuilder(); for(int i=0;i&lt;index;i++)&#123; builder.append(pairs[i][0].toString()); builder.append(\" : \"); builder.append(pairs[i][1].toString()); if(index&gt;i) builder.append(\"\\n\"); &#125; return builder.toString(); &#125; public static void main(String[] args)&#123; MappingTable&lt;String,String&gt; map = new MappingTable&lt;String,String&gt;(5); map.put(\"kaka\",\"15\"); map.put(\"lisa\",\"20\"); map.put(\"yita\",\"18\"); System.out.println(map); System.out.println(map.get(\"lisa\")); &#125;&#125; 这个map实现的比较简单，可以看到上面我们自己实现的容器，无论是存放，还是取值，都要进行一次线性的查找，如果是几十个数据量还好，但是如果一个Map集合中想要存放成千上万个元素呢？难道我们每次都要从头到尾遍历一遍？这效率想想就低的可怕哈，有没有一种可以直接访问的方法，所以java类库的Map实现就引入了HashCode（散列码）的方式来取代对键值的缓慢的线性查找。在根类Object中，有一个hashCode()方法，他是一个native方法，默认是根据对象的某些信息转换得到的，理论上是相对唯一的，所有java对象都可以生成自己的散列码，而HashMap就是通过对象的散列码进行快速查询的。下面我们继续看看散列是啥。 散列和散列码 在看散列前，我们先看一个关于Hashmap的例子。测试Java中的hashmap到底是依靠什么进行工作的，是通过equals()方法保证键值的唯一吗？我们自己编写的类，不覆写hashcode()方法，存放在hash类型的集合中，能保证唯一吗？来看看吧！ 先来看一个例子，如果我们编写自己的类作为HashMap的键，不覆写他的hashCode(）方法，看看HashMap能否正常工作。 射击运动员（键） — Shooter他的射击靶数（值）— TargetNum Shooter类： 123456789101112package ch17.deepincontainers;public class Shooter &#123; private int id; public Shooter(int id)&#123; this.id = id; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return \"Shooter#\"+id; &#125;&#125; TargetNum类： 1234567891011package ch17.deepincontainers;import java.util.Random;public class TargetNum &#123; private Random rand = new Random(); String targetNum = String.format(\"TargetNum is %.2f\", rand.nextDouble()*10); @Override public String toString() &#123; // TODO Auto-generated method stub return targetNum; &#125;&#125; TestHashMap类： 123456789101112131415161718192021222324252627package ch17.deepincontainers;import java.lang.reflect.Constructor;import java.util.*;import java.util.Map.Entry;public class TestHashMap &#123; public static void main(String[] args)throws Exception &#123; // TODO Auto-generated method stub testHashMap(Shooter.class); &#125; public static&lt;T extends Shooter&gt; void testHashMap(Class&lt;T&gt; type) throws Exception&#123; Map&lt;Shooter,TargetNum&gt; map = new HashMap&lt;Shooter,TargetNum&gt;(); Constructor&lt;T&gt; cons = type.getConstructor(int.class); for (int i = 0; i &lt; 10; i++) &#123; map.put(cons.newInstance(i), new TargetNum()); &#125; for(Entry e:map.entrySet())&#123; System.out.println(e+\" hashcode: \"+e.getKey().hashCode()); &#125; System.out.println(\"-------after put------\"); map.put(cons.newInstance(3),new TargetNum()); for(Entry e:map.entrySet())&#123; System.out.println(e+\" hashcode: \"+e.getKey().hashCode()); &#125; System.out.println(\"-----can i get by my key-----\"); System.out.println(map.get(cons.newInstance(3))); &#125;&#125; 看看下面的输出结果： 123456789101112131415161718192021222324Shooter#8=TargetNum is 0.04 hashcode: 621009875Shooter#1=TargetNum is 8.33 hashcode: 1735600054Shooter#4=TargetNum is 3.46 hashcode: 1836019240Shooter#6=TargetNum is 7.27 hashcode: 1173230247Shooter#9=TargetNum is 1.71 hashcode: 1265094477* Shooter#3=TargetNum is 8.01 hashcode: 2133927002 Shooter#5=TargetNum is 7.66 hashcode: 325040804Shooter#0=TargetNum is 4.58 hashcode: 356573597Shooter#2=TargetNum is 7.02 hashcode: 21685669Shooter#7=TargetNum is 1.47 hashcode: 856419764-------after put------Shooter#8=TargetNum is 0.04 hashcode: 621009875Shooter#1=TargetNum is 8.33 hashcode: 1735600054* Shooter#3=TargetNum is 2.07 hashcode: 2125039532Shooter#4=TargetNum is 3.46 hashcode: 1836019240Shooter#6=TargetNum is 7.27 hashcode: 1173230247Shooter#9=TargetNum is 1.71 hashcode: 1265094477* Shooter#3=TargetNum is 8.01 hashcode: 2133927002Shooter#5=TargetNum is 7.66 hashcode: 325040804Shooter#0=TargetNum is 4.58 hashcode: 356573597Shooter#2=TargetNum is 7.02 hashcode: 21685669Shooter#7=TargetNum is 1.47 hashcode: 856419764-----can i get by my key-----null 结果显然是不能正常工作，不仅相同的键值被重复添加在map中呢，并且不能正常取值。在看hashmap的源码前，我们在进行下其他的猜想，其一，是不是没有覆写对象的equals方法导致添加了重复的键值，其二，没有覆写对象的hashcode方法导致我们无法取值，既然如此，我们在写两个类测试下。 class ShooterJustOverEquals: 123456789101112131415161718192021public class ShooterJustOverEquals extends Shooter &#123; public ShooterJustOverEquals(int id)&#123; super(id); &#125; @Override public boolean equals(Object obj) &#123; return obj instanceof ShooterJustOverEquals &amp;&amp; this.getId() == ((ShooterJustOverEquals) obj).getId(); &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return \"ShooterJustOverEquals:\"+getId(); &#125; public static void main(String[] args) throws Exception&#123; TestHashMap.testHashMap(ShooterJustOverEquals.class); &#125;&#125; 结果如下 123456789101112131415161718192021222324ShooterJustOverEquals:8=TargetNum is 3.04 hashcode: 621009875ShooterJustOverEquals:1=TargetNum is 4.70 hashcode: 1735600054ShooterJustOverEquals:4=TargetNum is 7.44 hashcode: 1836019240ShooterJustOverEquals:6=TargetNum is 2.52 hashcode: 1173230247ShooterJustOverEquals:9=TargetNum is 6.13 hashcode: 1265094477* ShooterJustOverEquals:3=TargetNum is 4.84 hashcode: 2133927002ShooterJustOverEquals:5=TargetNum is 4.85 hashcode: 325040804ShooterJustOverEquals:0=TargetNum is 5.97 hashcode: 356573597ShooterJustOverEquals:2=TargetNum is 8.69 hashcode: 21685669ShooterJustOverEquals:7=TargetNum is 9.17 hashcode: 856419764-------after put------ShooterJustOverEquals:8=TargetNum is 3.04 hashcode: 621009875ShooterJustOverEquals:1=TargetNum is 4.70 hashcode: 1735600054* ShooterJustOverEquals:3=TargetNum is 3.35 hashcode: 2125039532ShooterJustOverEquals:4=TargetNum is 7.44 hashcode: 1836019240ShooterJustOverEquals:6=TargetNum is 2.52 hashcode: 1173230247ShooterJustOverEquals:9=TargetNum is 6.13 hashcode: 1265094477* ShooterJustOverEquals:3=TargetNum is 4.84 hashcode: 2133927002ShooterJustOverEquals:5=TargetNum is 4.85 hashcode: 325040804ShooterJustOverEquals:0=TargetNum is 5.97 hashcode: 356573597ShooterJustOverEquals:2=TargetNum is 8.69 hashcode: 21685669ShooterJustOverEquals:7=TargetNum is 9.17 hashcode: 856419764-----can i get by my key-----null 可以看到，我们覆写了equls方法，但是没有起作用，我可以猜测是不是要结合hashcode方法才能生效呢？我们接下来继续试一把 ShooterOverEqualsAndHashcode: 1234567891011121314151617181920public class ShooterOverEqAndHashcode extends ShooterJustOverEquals &#123; public ShooterOverEqAndHashcode(int id) &#123; super(id); // TODO Auto-generated constructor stub &#125; @Override public int hashCode() &#123; return getId(); &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return \"ShooterOverEqAndHashcode#\"+getId(); &#125; public static void main(String[] args) throws Exception &#123; TestHashMap.testHashMap(ShooterOverEqAndHashcode.class); &#125;&#125; 结果： 1234567891011121314151617181920212223ShooterOverEqAndHashcode#0=TargetNum is 6.34 hashcode: 0ShooterOverEqAndHashcode#1=TargetNum is 1.33 hashcode: 1ShooterOverEqAndHashcode#2=TargetNum is 1.13 hashcode: 2ShooterOverEqAndHashcode#3=TargetNum is 6.43 hashcode: 3ShooterOverEqAndHashcode#4=TargetNum is 4.49 hashcode: 4ShooterOverEqAndHashcode#5=TargetNum is 9.18 hashcode: 5ShooterOverEqAndHashcode#6=TargetNum is 0.67 hashcode: 6ShooterOverEqAndHashcode#7=TargetNum is 2.66 hashcode: 7ShooterOverEqAndHashcode#8=TargetNum is 8.27 hashcode: 8ShooterOverEqAndHashcode#9=TargetNum is 4.49 hashcode: 9-------after put------ShooterOverEqAndHashcode#0=TargetNum is 6.34 hashcode: 0ShooterOverEqAndHashcode#1=TargetNum is 1.33 hashcode: 1ShooterOverEqAndHashcode#2=TargetNum is 1.13 hashcode: 2ShooterOverEqAndHashcode#3=TargetNum is 2.92 hashcode: 3ShooterOverEqAndHashcode#4=TargetNum is 4.49 hashcode: 4ShooterOverEqAndHashcode#5=TargetNum is 9.18 hashcode: 5ShooterOverEqAndHashcode#6=TargetNum is 0.67 hashcode: 6ShooterOverEqAndHashcode#7=TargetNum is 2.66 hashcode: 7ShooterOverEqAndHashcode#8=TargetNum is 8.27 hashcode: 8ShooterOverEqAndHashcode#9=TargetNum is 4.49 hashcode: 9-----can i get by my key-----TargetNum is 2.92 这回我们看到，HashMap正常在工作呢，我们调转到hashmap的源码中去看看两个关键位置的操作 put({key : value}) get(key) 发现Hashmap的底层实现是这样的，我们用一张图来说明： 更进一步,如何写个HashMap容器 现在我们知道了散列的原理，那么实现一个简单的HashMap也就没那么困难呢，我们接下来也尝试实现一个简单的SimpleHashMap，在此之前，先和大家来看看一个标准的map容器是一个怎么样的大体结构，我们来仿照这个结构编写我们的hashmap AbstractMap这个抽象基类，这个基类包含了一个抽象方法public abstract Set","tags":[{"name":"java","slug":"java","permalink":"https://llcat.github.io/tags/java/"},{"name":"collections","slug":"collections","permalink":"https://llcat.github.io/tags/collections/"}]},{"title":"hexo+githubpages搭建个人blog","date":"2017-04-13T13:29:35.000Z","path":"others/hexo-githubpages搭建个人blog/2017-04/","text":"为什么我要选hexo?一直以来想要自己搭个博客,甚至有想建站搭个动态博客的想法,但是败给了懒……然后在逛一些大大的blog时发现,他们的博文写的好也就算了,为啥界面还这么好看,然后就就发现了hexo这个草鸡漂亮而且方便好用的blog框架,好吧,种草许久了,早就想拔呢,最近这段时间也想把先前写在wiznote中的笔记转出来,好吧,那让我们开始愉快的动手吧。 工具准备（带把小铁锤开始我们的工作吧） tool link git https://git-scm.com/ node.js https://nodejs.org/en/ github pages https://pages.github.com/ 上面列举的工具就是我们接下来会用到的啦，请大家根据需要自行去官网下载:-O因为我是用的linux-ubantu,所以git是自带的，我需要准备工具只有node.js呢，当然我会在后面给出相关工具安装使用的帖子，希望能帮到大家。 node.js的安装好吧，Linux下好像不需要装，下载后解压即用，真刺激。需要注意的是为了方便使用，我们最好需要对node,和npm做两个全局的链接。 1234# 我将node.js执行文件解压后放在了 /usr/local/node/呢，当然这个你们随意啦# ln(link) -s (建一个软链接) 源文件(解压后的目录下的程序） 目标文件(生成的链接文件） ln -s /usr/local/node-v6.10.2/bin/node /usr/local/bin/nodeln -s /usr/local/node-v6.10.2/bin/npm /usr/local/bin/npm hexo安装hexo安装命令就在他们的官网首页，相当的简单，just one! 12# 可能我们需要给hexo也配置下全局的一个链接，同上npm install hexo-cli -g 到此我们需要的工具准备完毕了，如果大家在安装过程中遇到了什么困难，可以参考下面的文档或blog hexo 中文文档ubantu下安装hexo blog 开始用它之前尝试了解它吧hexo给我们提供了详尽的文档，很多具体的细节需要我们去通读一遍hexo docs,下面是我自己对文档内容的一些梳理。 大体步骤 建站 更改配置文件 写作 部署 建站 1234hexo init blogcd blognpm installhexo server 上面的几条命令是建站的基本命令了，其中npm install默认是安装需要的工具，其中包括了我们的hexo server,所有安装的工具都可以在根目录下的package.json中看到了。hexo init 之后，整个文件夹变为我们的工作目录，目录结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 文件 作用 _config.yml 我们配置的主要信息都在这，网站标题，url，站点存放目录，主题，模板设置等，详情 package.json 已经安装的工具信息 scaffolds 模板文件，我们的每篇blog肯定有一些相同的内容，如开头的front-matter,默认scaffolds文件夹中包含3个模板，post.md,page.md,drafts.md对应了我们三种layout(布局） source 存放一些源文件，包括我们的blog.md,在_post中存放那个的是以hexo [layout,default post] new title.md建立的文件 themes 主题，你可以在hexo-themes挑选一个自己喜欢的主题替换默认的landscape,我使用了litten大大的yilia主题 修改配置文件 我们需要简单修改下默认的_config.yml文件，替换为自己的一些信息就可以使用呢，详情参考一般来说，我们仅需要修改下面几个相关内容的配置就可以使用了 网站 参数 说明 title 网站的标题 description 网站的描述 author 作者 language 网站使用的语言 网址 参数 说明 url 你blog的url,比如使用的是github pages,那么改为https:username.github.io root 根目录，一般为/，如果你想把部署的静态文件放在网站的二级目录www.xxx.com/blog下，设置为/blog 目录 配置工作目录的一些信息，比如源文件，标签文件，分类文件存放在那些目录下，对于新手来说，不需要更改此部分的配置 文章 对于文章的一些设置，如设置标题格式，文章默认布局，是否显示草稿等 写作 我们开始写作时，需要新建一篇文章，使用hexo new ‘xxx.md’,这个命令会在source的_post中生成一个xxx.md文件，我们可以在scaffolds中建立自己的layout模板文件，使用自己的模板新建文章 1234# post是我们配置的默认模板，可以省略不写hexo new post &apos;hexo+github pages搭建个人blog.md&apos;# 还可以使用自己的模板文件新建文章hexo new myscaffolds &apos;xxx.md&apos; markdown 语法 对于写好的文章，我们通过hexo gor hexo generate来生成静态文件，这些文件存放在public文件夹中，也是我们需要部署到网站上的文件，包括一些配置文件,html,css,js，img等。 部署blog 部署blog的方式有很多种，官方提供了多样化的部署方式，我们本次采用的方式是基于git部署我们的blog到github page上去，需要安装一个新的工具 1npm install hexo-deployer-git --save 修改配置文件_config.yml123deploy: type: git repo: git@github.com:llcat/llcat.github.io.git 部署123hexo deploy# 或者用简称hexo d 自己出现的一些错误开启了post_asset_folder: true后将图片放在相应文件夹下时，使用hexo g生成文件时报错如下FATAL ENOTDIR: not a directory, open ‘/home/ypl/StudyNotes/blog/public/java/了解Map容器/2017-04/abstract_map.jpg’ 说找不到这个文件夹，百度了一圈后发现是在_config.yml文件中一个设置出现了错误，在year-:month后少打了一个反斜线，hexo认为我配置的这个永久链接是个文件，不是文件夹，更改配置如下后正常permalink: :category/:title/:year-:month/","tags":[{"name":"github pages","slug":"github-pages","permalink":"https://llcat.github.io/tags/github-pages/"},{"name":"hexo","slug":"hexo","permalink":"https://llcat.github.io/tags/hexo/"}]}]